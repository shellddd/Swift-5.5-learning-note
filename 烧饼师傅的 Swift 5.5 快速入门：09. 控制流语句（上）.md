# 烧饼师傅的 Swift 5.5 快速入门：09. 控制流语句（上）
控制流是什么流？据江湖传言，Swift 门下有诸多神秘流派，其实在之前的很多代码中，我们已经见识过很多诸如 `if-else`, `for-in`，和即将出场的可以执行多次任务的 `while` 、选择分支的 `guard`、 `switch` 这样的选控流，还有跳 `continue` 、破 `break` 、串 `fallthrough` 返 `return` 、抛 `throw` ，这些直控流的兄弟。<br />

轮回、选择、直控这三大流派就统称为控制流。而一切的控制，都是为了更好地轮回，就让我们从轮回开始吧。
## `for-in` 轮回
轮回在现代汉语中，被称之为循环，少了一些迷信色彩，多了一点科幻范儿。我们可以用 `for-in` 这个循环语句来遍历公司中的每个员工。下面，使用 `for-in` 来给员工点名，先建一个数组：
```
let 花名册 = ["王大胡子","张大胡子","李小辫子"]
for 花名 in 花名册 {
    print("早上好，\(花名)!")
}
```
代码中用来遍历的元素是3个员工姓名，`花名` 首先被赋值为第1个员工姓名 `王大胡子` ，然后循环中的语句，每执行一次，`花名` 的值就被更新为下一个姓名，直到循环结束。需要注意的是，`花名` 作为一个在循环中被自动赋值的常量，它不需要使用 `let` 这样的显示声明，只需将其包含在循环中，就可对其进行隐式声明。
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/ffc1585b-4aeb-45dc-a804-dc9f8f23df4e)

再用字典建一个工资表：
```
let 工资表 = ["王大胡子":80000,"张大胡子":50000,"李小辫子":30000]
for (姓名,工资) in 工资表 {
    print("\(姓名)的工资是\(工资)元。")
}
```
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/a037bb67-e330-4912-a2b5-acf68237fc34)

上面的代码，我们可以看到，`"王大胡子":80000` 就是一个元组，它的 `key` 和 `value` 分别是 `String`和 `Int` 。王大胡子、张大胡子、李小辫子这3个元组，就组成了一个字典。
## `While` 循环
`while` 循环在运行前，会首先判断条件是否成立，如果条件为 `true` ，运行循环，为 `flase`，则循环结束。下面我们就用 `while` 来专门为你设计一个“大帅哥回家记”的小游戏。
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/5be85f91-c045-45e2-992c-32cc2332154e)

规则如下：<br />
1 . 每一轮，通过投掷骰子来确定行动步数。<br />
2 . 如果停在面包店，获得动力，进1步，如果停在酒吧，则丧失体力，退3步。<br />
3 . 回家的路程一共是10步，如成功到达终点处的家，即游戏结束。<br />
先设置一个名称为 `总路程` 的常量，然后设置一个名称为 `路程` 的数组，由11个 `Int` 0值初始化（不是10个哦，还记得数组的序列是从0开始的吗）。`路程` 的长度由 `总路程` 来决定。
```
let 总路程 = 10
var 路程 = [Int](repeating:0, count:总路程 + 1)
```
一些特定的 `路程` 被设计为非0的值，例如集合面包店的值是一个正1，会让我们前进多1步，而街角的酒吧是一个负值3，则会让我们倒退3步。
```
路程[3] = 1; 路程[5] = 1; 路程[7] = -3
```
你-大帅哥从 `路程[0]` 开始前进，让我们设置一个 `掷骰子` 的变量，以 `0` 为初始值。然后设置 `帅哥到哪了` 必须小于 `总路程` 的条件，首先判断这个条件成立以后，开始掷骰子：
```
var 帅哥到哪了 = 0
var 掷骰子 = 0
while 帅哥到哪了 < 总路程 {
    掷骰子 += 1
    if 掷骰子 > 6 {掷骰子 = 1}
    帅哥到哪了 += 掷骰子
    if 帅哥到哪了 < 路程.count {
        帅哥到哪了 += 路程[帅哥到哪了]
    }
}
print("成功回家！")
```
在这个小游戏中，我们用了一个最简单的方法来模拟掷骰子，它的值不是随机的，而是随着每一次循环，值递增1，因为骰子的最大值为6，所以需要设置一个条件语句来检测 `掷骰子` 的值是否超过了6，如果超过，就把它重置为1。<br />
每掷1次骰子，大帅哥-你就按照 `掷骰子` 的值向前移动。但是如果在后续的路程中，1次移动就超过了`路程[10]` ,例如我们在 `路程[6]`，掷出了5，那么 `路程[帅哥到哪了]` 就会越界访问 `路程11` ，而这是一个超出 `路程` 数组范围的值，这时就会导致程序运行错误。<br />
为了应对这种情况，我们可以设置一个条件，即如果`帅哥到哪了` 小于 `路程` 的 `count` 属性，才能在 `路程[帅哥到哪了]` 的值上增加 `帅哥到哪了` 的值，来使我们向前或向后移动。就这样，判断——移动，不停循环，最后，移动的路程等于或大于总路程，结束游戏。<br />
**Repeat-While**
`repeat-while` 是 `while` 的另一种表现形式。如果说 `while` 是先买票后上车的话，`repeat-while` 则是先上了车再说买票的事。<br />
还是以上面大帅哥回家为例，看看 `repeat-while` 是如何运用的，前置数据都是差不多的，除了大帅哥的老婆在面包店看见大胡子哥哥，花了一小下痴以外：
```
let 总行程 = 10
var 行程 = [Int](repeating:0, count:总行程 + 1)
行程[3] = -1; 行程[5] = -1; 行程[7] = 3
var 你老婆到哪了 = 0
var 扔骰子 = 0
repeat {
    你老婆到哪了 += 行程[你老婆到哪了]
    扔骰子 += 1
    if 扔骰子 > 6 {扔骰子 = 1}
    你老婆到哪了 += 扔骰子
} while 你老婆到哪了 < 总行程
print("成功回家！")
```
发现不同了吗？在这个循环中，首先是你老婆掷完骰子就走，走完了以后，再去判断是否小于总行程的条件，如果是大于 ，就结束游戏。<br />
你可能有疑问，为什么我老婆就可以搞特殊化，不用做前置条件判断呢？这位先生，请不要误会，其实不光是您老婆，先生-您也可以。因为这是由游戏规则，来决定我们选择使用哪种 `while`循环的。<br />
在这个游戏规则中，骰子最大值为6，所以无论你再怎么掷，游戏的初始行动路程也不会大于总行程，这样我们就可以无需先行判断条件，也节省了对超出数组范围检查的步骤。先上车，后补票，何乐而不为呢！说不定还能白……<br />
>思考：在`Repeat-Wile`循环中，针对最后判断条件的这个优势，我们也可以加入一个对超出数组范围的检查。目的是，当掷出了超过总行程的值时，可以让游戏角色按照超出的值，做倒退移动，这样更增加了游戏乐趣。参考以下代码：
```
if 你老婆到哪了 >= 行程.count {
你老婆到哪了 = 10 - (行程[你老婆到哪了] - 10)
}
```
## 想一想最后这支代码到底做了什么？竟会令到你老婆可以遇家门而不入，一退3步杀向酒吧的呢？
