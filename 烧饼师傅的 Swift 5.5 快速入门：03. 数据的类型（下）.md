# 烧饼师傅的 Swift 5.5 快速入门：03. 数据的类型（下）
## 可选值类型：`Optional`
可选值类型是 Swift 语言中特有的一种类型，它不会单独存在，就像是一个幽灵，总是喜欢附身在某个具体的数据类型身上。它只有2种值，一种是附身数据有具体的值，那么可选就是该值；另一种是附身数据没有值，可选为空值 `nil` 。
我们知道，不论是整数还是字符串，都必须给它赋一个确定的值，可是在实际使用当中，我们经常会遇到不确定有没有的情况，例如你老婆想减肥，朋友告诉她，吃奶油水果蛋糕呀，吃咖哩牛肉面包啊。她听了以后，也不确定有没有效果，于是效果有还是没有？这就是个问题。 所以我们在普通类型后面加一个 `?` 来代表可选类型 `Optional` ：
```
let 多吃咖哩牛肉面包:String? = "吃了就变大肌霸！" 
if 多吃咖哩牛肉面包 != nil {print(多吃咖哩牛肉面包!)}
```
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/82b6e3c0-0525-4123-9ea5-92364ee32b0c)

上面的代码，就是卖蛋糕那小子，用 `?` 把奶油蛋糕和牛肉面包，包裹成了两个盲盒。你用比较运算符等于 `==` 或不等于 `!=` 来猜测盲盒里是否有值，在你和你老婆都预判奶油蛋糕与牛肉面包都不等于空 `nil` 的情况下，你先拆开了牛肉面包，诶，里面有一个值，你一开心，就在牛肉面包后面加了一个 `!` ，让它输出了 `吃了就变大肌霸！ ` 的效果，这个感叹号 `!` 就表示“诶！赚了！这货有东西！这货有东西！”，这被称为可选值的强制解析！你老婆还追着问你，那……那……那减肥呢？奶油蛋糕呢？你赶紧也给它加个感叹号呀！

**nil** 
只能给可选的变量或常量赋值，来表示它没有值。也就是说，如果我们要给一个常量或变量赋值为 `nil` ，必须先将其声明为相对应的可选类型，例如：
```
var 多吃奶油水果蛋糕: String? = "吃了就变苗条！"
// 多吃奶油水果蛋糕 现在包含一个可选的 String 值 "吃了就变苗条！"
多吃奶油水果蛋糕 = nil
// 多吃奶油水果蛋糕 现在不包含值。
var 要不要买几个蛋糕: Int?
// 要不要买几个蛋糕 如果不赋值给它，就会自动被设置为 nil。
要不要买几个蛋糕 = 0
// 买几个蛋糕呢 现在包含一个 Int 值为 0 。
if 多吃奶油水果蛋糕 == nil {print(多吃奶油水果蛋糕!)}
if 要不要买几个蛋糕 != nil {print(要不要买几个蛋糕!)}
```
使用 `!` 来强制解析值之前，必须确保可选值包含一个非 `nil` 的值。上面代码中，当 `多吃奶油水果蛋糕` 的值为 `nil` 时，我们也判断包裹中的值等于空 `nil` 的情况下，强制解包，就会提示错误：在解开可选值时意外发现 nil ，操作失败。
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/e5ff7dbc-85c1-4cf1-b69b-90903da485a8)

所以你为了给你老婆圆一个美丽的梦，只有用 `//` 注释符号把 `奶油水果蛋糕 = nil ` 屏蔽掉，并判断它的值不等于 `nil`， 再次执行：
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/a68c9d13-5760-45c5-a2e0-76570176ce67)

>注意：`nil` 和整数 `0` 、或空字符串 `""` 是不同的，`0` 和`""` 都是一个具体的值，而 `nil` 代表没有，它不是一个值，连空值 `""` 都不如，人虽然也空，但人至少还有一副好皮囊呀。 `nil` 是压根儿就不存在于这个世界中，它只是 Swift 星人幻想出来的一个符号，你让我怎么附身啊！
```
let 卖蛋糕那小子:String? = nil
let 奶油水果蛋糕:String? = ""
let 购买量:Int? = 0
if 卖蛋糕那小子 != nil {print("卖蛋糕那小子就是个\(卖蛋糕那小子!)!")}
if 奶油水果蛋糕 != nil {print("吃再多蛋糕也是一场\(奶油水果蛋糕!)!")}
if 购买量 != nil {print("所以我们买个\(购买量!)!")}
//输出比较一下，看看变化在哪里？
```
**可选绑定** 
除了使用强制解析，我们还可以使用可选绑定来判断可选类型是否包含值，同时把值绑定给一个新常量或变量。例如：
```
let 咖喱牛肉面包:String? = "吃了就变大肌霸！"
if var 肌霸面包 = 咖喱牛肉面包 {
    print("我只吃肌霸面包，\(肌霸面包)!")
}
```
上面就是如果 `咖喱牛肉面包` 中确定有值的话，就把这个值绑定在一个新建的变量  `肌霸面包` 中输出。由于 `咖喱牛肉面包` 中包含的值已经通过条件语句 `if` 直接赋值给 `肌霸面包` 了，此时，`肌霸面包` 中的值是一个非可选类型，所以也就不再需要附加 `!` 后缀来强制获取它的值了。
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/e70be94b-56c4-4362-a0bd-0b038957e9fb)

我们还可以同时绑定多个可选和多个布尔值在同一个条件语句中，用逗号 `,` 隔开即可。例如：
```
let 面包店营业状态:String? = "营业中", 咖喱牛肉面包销售:String? = "有余", 有余量 = 3, 购买量 = 2
if let 状态 = 面包店营业状态, let 销售 = 咖喱牛肉面包销售, 购买量 < 有余量 {
    print("面包店在\(状态)，面包的数量还\(销售)，我要去买\(购买量)个。")
}
```
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/532a07f6-67b7-4610-901a-d84f228f7846)

**隐式解析可选** 
可以看到，无论是强制解析还是可选绑定，都必须先使用 `if` 语句来判断值是否存在，如果确实存在就解包并获取该值。 在实际使用当中，其实很多时候，我们已经很明确地知道这个可选类型就是有值存在，那么有没有更简单的方法，让我们不用每次访问该值时，都要先进行一次判断和解包的过程呢？
当然是有的，这种类型就被定义隐式解析可选，它的使用方式就是在声明可选类型时，并确定知道该值不为空时，那么就可以在类型后面加一个 `!`提前强制解析。
啥？啥选？我勒个乖乖！这名字咋恁拗口哩！嗨！要俺说啊，这就是人面包店的帅哥老板，地道。知道我老婆下晚班，每次买面包前，都要先打电话去问下有没有，所以人干脆就在面包刚出炉那会儿，就悄悄地把我老婆喜欢吃的，给强行截留了。这样她一去，就总能买到，绝对不会扑空。善解人意，是这个意思吧！
```
let 没帅哥的面包店:String? = "面包可能还有余？"
let 能买到面包吗:String = 没帅哥的面包店!
//需要在后缀附加一个感叹号。
let 有帅哥的面包店:String! = "面包提前给您留好！"
let 肯定买到面包:String = 有帅哥的面包店
//不需要在后缀附加一个感叹号。
print("没帅哥的面包店里，\(能买到面包吗)")
print("有帅哥的面包店里，\(肯定买到面包)")
```
![image](https://github.com/shellddd/Swift-5.5-learning-note/assets/67853933/06488325-9f16-426d-ad68-6ff405aa7409)


## 就在我敲入上面文字的时候，秋香发来一条信息给我，上面有几行代码：
```
let 想听假话 = false
let 想听真话 = true
if 想听真话 {
    print("俄把阿强轰走咧！")
} else {
    print("你下周有莫时间？")
}
//猜一猜我的屏幕上会输出什么结果呢？
```
## 猜一猜我的屏幕上会输出什么结果呢？
